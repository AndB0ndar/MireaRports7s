\section*{ЦЕЛЬ ПРАКТИЧЕСКОЙ РАБОТЫ}
\addcontentsline{toc}{section}{ЦЕЛЬ ПРАКТИЧЕСКОЙ РАБОТЫ}

План практической работы:

\begin{itemize}
	\item Ознакомиться с задачами хранения состояния;
	\item Произвести знакомство с Bloc;
	\item Произвести знакомство с Riverpod;
	\item Произвести знакомство с MobX;
	\item Выполнение практической работы \No\,10.
\end{itemize}

\clearpage

\section*{ВЫПОЛНЕНИЕ ПРАКТИЧЕСКОЙ РАБОТЫ}
\addcontentsline{toc}{section}{ВЫПОЛНЕНИЕ ПРАКТИЧЕСКОЙ РАБОТЫ}

\section{Задача хранения состояния}

Управление состоянием мобильных приложений --- это фундаментальная концепция
всех мобильных фреймворков для разработки приложений,
и Flutter не является исключением.
Управление состоянием --- это то, как приложение может управлять данными,
которые оно использует, и обновлять их.
Во Flutter существует несколько техник и инструментов,
которые можно использовать для управления состоянием,
и выбор наиболее подходящего из них часто зависит от
сложности и требований приложения, которое создается.

\section{Bloc}

Bloc (Business Logic Component) и Cubit --- это решения
для управления состоянием, входящие в состав пакета \texttt{flutter\_bloc}.
Bloc работает на основе событий и состояний,
в то время как Cubit является более простой версией Bloc
и работает непосредственно с изменениями состояния.
Оба подхода позволяют отделить бизнес-логику от пользовательского интерфейса,
что упрощает поддержку и тестирование приложения.

\subsection{Подключение пакетов}

Для работы с Bloc и Cubit необходимо добавить зависимости
в файл \texttt{pubspec.yaml}.
Это позволяет подключить нужные пакеты
для работы с состоянием в Flutter приложении.

Пример содержимого файла \texttt{pubspec.yaml}
показано на рисунке~\ref{fig:bloc:pubspec}.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 17-32-18}
	\caption{pubspec.yaml}
	\label{fig:bloc:pubspec}
\end{image}

\subsection{Реализация общего слушателя}

Одной из полезных возможностей при использовании \texttt{flutter\_bloc}
является наличие общего слушателя \texttt{BlocObserver}.
Этот объект позволяет отслеживать все изменения состояния в приложении.
С его помощью можно вести логирование событий, ошибок и изменений состояний.

Для реализации \texttt{BlocObserver}, нужно создать класс,
который будет наследовать \texttt{BlocObserver} \rref{fig:bloc:observer}.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 17-39-57}
	\caption{Класс общего слушателя}
	\label{fig:bloc:observer}
\end{image}

Данный класс отслеживает события, изменения состояний и ошибки,
что позволяет мониторить состояние блоков в приложении.

\subsection{Подготовка Widget-а приложения}

Затем в файле \texttt{main.dart} необходимо зарегистрировать
\texttt{BlocObserver} перед запуском приложения \rref{fig:bloc:main}.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 17-45-18}
	\caption{main.dart}
	\label{fig:bloc:main}
\end{image}

Следующим шагом является подготовка основного виджета приложения.
В приведенном примере используется \texttt{TaskTrackerApp},
который инициализирует приложение с помощью \texttt{MaterialApp},
устанавливает основную страницу и предоставляет \texttt{BlocProvider}
для управления состоянием \rref{fig:bloc:app}.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 17-46-47}
	\caption{Основной виджет приложения}
	\label{fig:bloc:app}
\end{image}

В данном коде:

\begin{itemize}
	\item Создается \texttt{MaterialApp} с базовой темой.
	\item Используется \texttt{BlocProvider},
		который предоставляет \texttt{TaskCubit}
		в дочерний виджет \texttt{TaskListScreen}.
\end{itemize}

\subsection{Реализация страницы задачи}

Для создания страницы задачи с возможностью добавления,
удаления и изменения статуса задач был реализован экран,
который отображает список задач
и позволяет взаимодействовать с состоянием через \texttt{Cubit}.

Пример содержимого страницы задач \texttt{TaskListScreen}
показан на рисунке~\ref{fig:bloc:list:screen}.

\begin{image}
	\includegrph[scale=0.37]{Screenshot from 2024-12-15 17-49-43}
	\caption{Код страницы задачи}
	\label{fig:bloc:list:screen}
\end{image}

Здесь:

\begin{itemize}
	\item Используется \texttt{BlocBuilder}
		для обновления состояния списка задач
		в зависимости от данных в \texttt{TaskCubit}.
	\item Визуализируется список задач с помощью \texttt{ListView.builder},
		где каждая задача имеет возможность быть удаленной
		или измененной по статусу (выполнена/невыполнена).
\end{itemize}

Отображение экрана представлено на рисунке~\ref{fig:bloc:list:show}.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 19-19-22}
	\caption{Стараница со списком}
	\label{fig:bloc:list:show}
\end{image}

\subsection{Реализация Cubit класса}

В приложении используется \texttt{Cubit},
который отвечает за управление состоянием задач.
\texttt{TaskCubit} предоставляет методы для добавления задач,
их удаления и изменения статуса.

Пример содержимого класса \texttt{TaskCubit}:

\begin{image}
	\includegrph{Screenshot from 2024-12-15 17-52-16}
	\caption{Cubit класс}
	\label{fig:bloc:cubit}
\end{image}

Методы:

\begin{itemize}
	\item \texttt{addTask(String title)} --- добавляет новую задачу в список.
	\item \texttt{removeTask(Task task)} --- удаляет задачу из списка.
	\item \texttt{toggleTaskStatus(Task task)} --- изменяет статус задачи
		(выполнена или нет).
\end{itemize}

\subsection{Реализация представления данных Bloc}

Класс \texttt{TaskListScreen} рендерит данные
с использованием \texttt{BlocBuilder}.
Этот виджет слушает изменения состояния в \texttt{TaskCubit}
и обновляет UI при каждом изменении состояния.

Пример рендеринга списка задач был продемонстрирован
на рисунке~\ref{fig:bloc:list:screen}.

В этом коде \texttt{BlocBuilder} следит за состоянием в \texttt{TaskCubit}
и обновляет \texttt{ListView} при изменении состояния
(добавление, удаление, изменение статуса задачи).

\clearpage

\section{Riverpod}

\textbf{Riverpod} --- это библиотека управления состоянием для Flutter,
являющаяся улучшенной версией более старой библиотеки \textbf{Provider}.
Она обеспечивает более безопасный, тестируемый
и гибкий способ управления состоянием
и его совместного использования в приложении.
В отличие от Provider, Riverpod не требует использования контекста
для получения состояния, что упрощает тестирование
и улучшает безопасность работы с состоянием.

\subsection{Подключение пакетов}

Для использования \textbf{Riverpod}
в проекте необходимо добавить соответствующие пакеты
в файл \texttt{pubspec.yaml} \rref{fig:riverpod:pubspec}.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 18-07-46}
	\caption{pubspec.yaml}
	\label{fig:riverpod:pubspec}
\end{image}

Здесь добавляется зависимость от пакета \texttt{flutter\_riverpod},
который необходим для использования функционала управления
состоянием с помощью Riverpod.

\subsection{Подготовка Widget-а приложения}

После добавления необходимых зависимостей,
необходимо настроить структуру приложения.
Основной элемент, который используется для интеграции с Riverpod,
это \texttt{ProviderScope}.
Он оборачивает приложение и управляет всеми провайдерами
в пределах своей области видимости.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 18-09-22}
	\caption{main.dart}
	\label{fig:riverpod:main}
\end{image}

\texttt{ProviderScope} --- это виджет,
который предоставляет область видимости для всех провайдеров в приложении.
Он нужен для того, чтобы отслеживать и управлять состоянием,
предоставляемым различными провайдерами.

Приложение создается в виде обычного \texttt{StatelessWidget}
с использованием \texttt{MaterialApp} для оформления,
при этом основная страница (\texttt{TaskListScreen}) будет виджетом,
на котором отображается список задач \rref{fig:riverpod:app}.
Само приложение остается таким же, как и в стандартных примерах Flutter,
но теперь оно использует Riverpod для управления состоянием.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 18-17-15}
	\caption{Основной виджет приложения}
	\label{fig:riverpod:app}
\end{image}

\subsection{Реализация страницы задач}

После подготовки приложения, следующим шагом является создание страницы,
которая будет отображать список задач \rref{fig:riverpod:list:screen}.
Для этого используется виджет \texttt{ConsumerWidget},
который является базовым для работы с Riverpod.

\begin{image}
	\includegrph[scale=0.37]{Screenshot from 2024-12-15 18-16-22}
	\caption{Код страницы задачи}
	\label{fig:riverpod:list:screen}
\end{image}

\texttt{ConsumerWidget} позволяет подписаться на изменения данных,
предоставляемых провайдерами.
В данном случае, \texttt{ref.watch(taskProvider)} используется
для отслеживания состояния задач,
и автоматического обновления экрана, когда данные меняются.
В этом примере задачи могут быть добавлены, удалены или изменены,
а интерфейс автоматически обновляется, когда происходит изменение состояния.

\subsection{Реализация класса-делегата}

Следующим шагом является создание класса-делегата,
который будет управлять состоянием задач.
Для этого используется \texttt{StateNotifier}
в сочетании с \texttt{StateNotifierProvider}, что позволяет изменять
и сохранять состояние задач \rref{fig:riverpod:provider}.

\begin{image}
	\includegrph[scale=0.6]{Screenshot from 2024-12-15 18-21-33}
	\caption{Класс-делегат}
	\label{fig:riverpod:provider}
\end{image}

\texttt{StateNotifierProvider} создает провайдер для управления состоянием,
а \texttt{TaskNotifier} --- это класс, который управляет списком задач.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 18-23-26}
	\caption{Класс TaskNotifier}
	\label{fig:riverpod:notifier}
\end{image}

\texttt{StateNotifier} позволяет эффективно управлять состоянием
и изменять его через методы, такие как \texttt{addTask}, \texttt{removeTask}
и \texttt{toggleTaskStatus}.
Каждый метод изменяет состояние
с помощью оператора присваивания \texttt{state =},
который обновляет текущее состояние списка задач.

Для того чтобы данный класс стал классом-делегатом,
необходимо указать аннотацию \texttt{@riverpod},
если используется такой подход.

\section{MobX}

MobX --- это библиотека управления состоянием,
основанная на концепции реактивного программирования.
В MobX состояние и пользовательский интерфейс (UI) приложения разделяются,
при этом интерфейс автоматически обновляется, когда состояние изменяется.
Это позволяет создать приложение с минимальными усилиями по обновлению UI,
упрощая поддержку и улучшая производительность.

\subsection{Подключение пакетов}

Для работы с MobX в проекте необходимо добавить соответствующие пакеты
в файл \texttt{pubspec.yaml}. Это включает в себя два основных пакета:

\begin{itemize}
    \item \texttt{mobx} --- основной пакет для реализации состояния с MobX.
    \item \texttt{flutter\_mobx} --- пакет для интеграции MobX с Flutter.
\end{itemize}

Содержимое раздела \texttt{dependencies}
и \texttt{dev\_dependencies} в файле \texttt{pubspec.yaml}
показано на рисунке~\ref{fig:mobx:pubspec}.

\begin{image}
	\includegrph{Screenshot from 2024-12-15 18-43-01}
	\caption{pubspec.yaml}
	\label{fig:mobx:pubspec}
\end{image}

В \texttt{dependencies} подключаются библиотеки для работы с MobX,
а в \texttt{dev\_dependencies} добавляются пакеты
для генерации кода (\texttt{build\_runner} и \texttt{mobx\_codegen}),
которые необходимы для автоматической генерации файлов,
содержащих методы и миксины для MobX.

\subsection{Реализация Store}

\texttt{Store} в MobX --- это класс,
который инкапсулирует все связанное наблюдаемое состояние.
Он позволяет использовать аннотации
и сохраняет код простым и удобным для работы.

Для начала создадим новый файл \texttt{lib/app\_mobx.dart},
где будет реализован наш Store для задач \rref{fig:mobx:store}.

В этом примере мы создаем класс \texttt{TaskStore},
который будет управлять состоянием задач.
Используем аннотации:

\begin{itemize}
    \item \texttt{@observable} --- для пометки переменных
		как наблюдаемых (состояния, которые могут изменяться).
    \item \texttt{@action} --- для пометки методов,
		которые изменяют состояние.
\end{itemize}

\begin{image}
	\includegrph{Screenshot from 2024-12-15 18-45-58}
	\caption{Реализация Store}
	\label{fig:mobx:store}
\end{image}

Обратите внимание,
что файл с расширением \texttt{.g.dart} генерируется автоматически
с помощью команды \texttt{flutter pub run build\_runner build}.
Это позволяет MobX генерировать необходимый код для работы с состоянием.

\subsection{Подключение Store к Observer}

После того как класс-делегат (Store) реализован,
следующим шагом является подключение
его к пользовательскому интерфейсу с использованием \texttt{Observer}
\rref{fig:mobx:list:screen}.

\begin{image}
	\includegrph[scale=0.37]{Screenshot from 2024-12-15 18-50-08}
	\caption{Код страницы задачи}
	\label{fig:mobx:list:screen}
\end{image}

В этом примере \texttt{Observer} используется для прослушивания изменений
в состоянии \texttt{taskStore}.
Когда данные изменяются, \texttt{Observer} автоматически обновляет виджет,
отображая актуальное состояние задач.

Встроенная логика обработки нажатий на чекбокс
и удаление задач теперь перенесена в методы Store,
благодаря чему приложение стало более эффективным и легко поддерживаемым.

\clearpage

\section*{ВЫВОД}
\addcontentsline{toc}{section}{ВЫВОД}

В ходе практической работы были изучены
задачи управления состоянием в Flutter
с использованием библиотек Bloc, Riverpod и MobX.
Реализовано приложение Task Tracker,
в котором каждая из библиотек использовалась
для управления списком задач.

Bloc позволил создать централизованное управление состоянием
через события и изменения.
Riverpod обеспечил гибкость и декларативный подход.
MobX показал себя удобным инструментом
для реактивного обновления интерфейса.

Результатом работы стало понимание особенностей этих библиотек
и умение применять их для решения задач управления состоянием
в приложениях Flutter.

