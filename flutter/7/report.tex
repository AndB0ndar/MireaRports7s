\section*{ЦЕЛЬ ПРАКТИЧЕСКОЙ РАБОТЫ}
\addcontentsline{toc}{section}{ЦЕЛЬ ПРАКТИЧЕСКОЙ РАБОТЫ}

План практической работы:

\begin{itemize}
	\item Асинхронное программирование;
	\item Асинхронные Future методы;
	\item Получение данных по итогу Future метода;
	\item Ожидание Future метода;
	\item Выполнение практической работы \No\,7.
\end{itemize}

\clearpage

\section*{ВЫПОЛНЕНИЕ ПРАКТИЧЕСКОЙ РАБОТЫ}
\addcontentsline{toc}{section}{ВЫПОЛНЕНИЕ ПРАКТИЧЕСКОЙ РАБОТЫ}

\section{Асинхронное программирование}

Часто в программировании при разработке сталкиваются с проблемой,
что невозможно получить результат функции сразу при ее выполнении.
Для этого применяется отдельная концепция программирования
--- асинхронное программирование.
Концепция такого программирования заключается в том,
что результат выполнения функции доступен не сразу,
а через некоторое время в виде некоторого асинхронного вызова,
нарушающего обычный порядок выполнения.\par
В отличие от синхронного программирования,
где компьютер выполняет инструкции последовательно
и ожидает завершения системных операций,
блокируя следующие операции в потоке выполнения,
в асинхронном программировании длительные операции запускаются
без ожидания их завершения и не блокируя дальнейшее выполнение программы\par
Что касается непосредственно языка Dart, то это однопоточный язык – он может выполнять только одну задачу в одно время. Тем не менее благодаря реализации цикла событий (event loop) и двух очередей событий (event queue и microTask queue) он позволяет асинхронно выполнять различные задачи.

Очередь MicroTask предназначена для хранения небольших внутренних задач – микрозадач и основном используется внутри Dart. Основная часть задач помещается в очередь Event – это внешние события, например, события графического интерфейса (например, нажатие кнопки в графических приложениях), таймеры, чтение-запись файлов, получения данных от внешних сетевых ресурсов и т.д.

Когда запускается любое приложение на Dart, начинает выполняться единственный поток приложения. Единственный поток Dart работает в рамках того, что называют изолятом (isolate). Каждый изолят имеет свою собственную выделенную область памяти, что гарантирует, что никакой другой изолят не сможет получить доступ к состоянию текущего изолята. Это означает, что нет необходимости в сложной системе блокировок и управления доступом к ресурсам и что конфиденциальные данные находятся в гораздо большей безопасности.

Единственный поток приложения инициализирует две очереди – MicroTask и Event, которые будут содержать задачи, которые необходимо будет выполнить. Далее поток запускает функцию main() и прежде всего выполняет в нем все синхронные задачи. Синхронные задачи в основном потоке всегда выполняются немедленно. Если Dart встречает долговыполняемую задачу, выполнение которой можно отложить, то она помещается в очередь событий Event Queue.

Когда Dart завершает выполнение синхронных задач, цикл событий (Event Loop) проверяет очередь микрозадач – Microtask Queue. Если эта очередь имеет какие-нибудь задачи, то цикл событий помещает их в основной поток для последующего выполнения.

Когда синхронные задачи и задачи из Microtask Queue завершили выполнение, цикл событий начинает выбирать задачи из очереди Event Queue и помещает их в основной поток, где они выполняются синхронно.

Если в очередь Microtask Queue поступит новая микрозадача, то цикл событий выполняет ее до любой последующей задачи из очереди Event Queue.

Этот процесс продолжается до тех пор, пока очереди не станут пустыми.

Например, когда пользователь через приложение на языке Dart собирается считать файл, эта работа выполняется не в потоке приложения Dart, а операционной системой внутри ее собственного процесса. Когда система завершит считывание файла, она передает результат обратно в приложение на Dart. B Dart помещает в очередь event queue некоторый код, который будет обрабатывать результат считывания файла.

\section{Асинхронные Future методы}

Код в Dart работает в одном треде выполнения. Если код занят долгими вычислениями или ожидает операцию I/O, то вся программа приостанавливается. Ключевым классом для определения асинхронных задач является класс Future. Класс Future представляет результат отложенной операции, которая завершит свое выполнение в будущем. Результатом операции может быть некоторое значение или ошибка. Объект Future может находиться в двух состояниях: незавершенном (Uncompleted) и завершенном (Completed). В незавершенном состоянии операция, которую представляет объект Future, возможно, уже начала выполняться, но результат еще не получен. В завершенном состоянии операция уже завершила свое выполнение, ее результат – некое значение или ошибка – получен.

\subsection{Стандартный конструктор}

Базовый конструктор класса \texttt{Future} \rref{fig:future:construct}
принимает только обратную функцию \texttt{computation}.
Данный конструктор создает объект Future,
который с помощью метода \texttt{Timer.run} запускает функцию
\texttt{computation} асинхронно и возвращает ее результат.\par
Тип \texttt{FutureOr<T>} указывает,
что функция \texttt{computation} должна возвращать
либо объект \texttt{Future<T>} либо объект типа \texttt{T}.
Например, чтобы получить объект \texttt{Future<int>},
функция \texttt{computation} должна возвращать
либо объект \texttt{Future<int>}, либо объект\texttt{int} 

\begin{image}
	\includegrph{Screenshot from 2024-10-12 19-58-09}
	\caption{Пример создания Future}
	\label{fig:future:construct}
\end{image}

В этом примере на рисунке~\ref{fig:future:construct} функция,
переданная в конструктор, будет немедленно выполнена,
но результат её выполнения будет доступен только через \texttt{then}.
Используется простой цикл for, чтобы показать, что операция занимает время.
После завершения асинхронной операции возвращается строка
\texttt{'Данные успешно загружены'}, которая будет обработана в \texttt{then}.
Если бы в процессе выполнения возникла ошибка,
она была бы обработана в \texttt{catchError}.

\subsection{Функция wait}

Функция \texttt{wait} \rref{fig:future} в Flutter
ожидает завершения нескольких \texttt{Future} и собирает их результаты.
Возвращает будущее, которое завершится,
когда все предоставленные \texttt{Future} завершатся, либо с их результатами,
либо с ошибкой, если какое-то из \texttt{Future} не удалось.

\begin{image}
	\includegrph{Screenshot from 2024-10-12 19-26-09}
	\caption{Пример запроса к API используя Future}
	\label{fig:future}
\end{image}

\subsection{Конструктор delayed}

У класса \texttt{Future} существует конструктор,
позволяющий выполнить логику после определенного промежутка времени.
Данный конструктор создает объект \texttt{Future},
который запускается после временной задержки,
указанной через первый параметр Duration.
Второй необязательный параметр указывает на функцию,
которая запускается после этой задержки.

Использования конструктора delayed можно увидить на 
предыдущем рисунке~\ref{fig:future}.

\section{Получение данных по итогу Future метода}

Как рассматривалось ранее, \texttt{Future} может находиться в двух состояниях:
незавершенном и завершенном.
Незавершенное состояние мы рассмотрели ранее, однако в основном,
класс \texttt{Future} используют для получения некого результата,
а именно для его завершенного состояния.
Если асинхронная операция завершается успешно, будущее завершается значением.
В противном случае он завершается с ошибкой.\par
\texttt{Future} объект типа \texttt{Future<T>}
завершается значением типа \texttt{T}.
Например, \texttt{Future} объект
с типом \texttt{Future<String>} создает строковое значение.
Если \texttt{Future} объект не создает никакого значения,
то тип \texttt{Future} объект --- \texttt{Future<void>}.\par
Если асинхронная операция, выполняемая функцией,
по какой-либо причине завершается с ошибкой,
Future объект завершается с ошибкой.

\subsection{Метод then}

При определении объекта \texttt{Future}
он находится в незавершенном состоянии и будет выполнен чуть позже.
Но как же поймать тот момент,
когда \texttt{Future} уже выполнен и перешел в завершенное состояние?
Для этого у \texttt{Future} определен метод \texttt{then} \rref{fig:future:2}.
Этот метод принимает функцию обратного вызова, которая будет срабатывать
при завершении \texttt{Future}.
В качестве единственного параметра функция принимает полученное
из \texttt{Future} значение.
В метод \texttt{then()} передается функция обратного вызова,
которая принимает параметр \texttt{value} --- это и будет то значение,
которое возвращается при выполнении задачи.\par
При необходимости мы можем содавать цепочки методов \texttt{then},
которые будут выполняться друг за другом.
Тогда параметр функции из каждого последующего метода\texttt{then} 
--- это результат функции из предыдущего метода \texttt{then}.

\begin{image}
	\includegrph{Screenshot from 2024-10-12 19-26-09}
	\caption{Пример получения данных по итогу Future метода}
	\label{fig:future:2}
\end{image}

\subsection{Метод catchError}

При работе операции, которую представляет \texttt{Future},
может возникнуть ошибка.
В этом случае при переходе в завершенное состояние \texttt{Future}
вместо конкретного значения будет хранить информацию об ошибке.
Для получения информации об ошибке можно использовать
метод \texttt{catchError()}, который работает аналогично методу
\texttt{then} --- также принимает функцию обратного вызова,
в которую передается информация об ошибке.
В качестве второго
и необязательного параметра метод \texttt{catchError} принимает функцию,
которая проверяет соответствие объекта ошибки некоторому условию и,
если объект ошибки соответствует этому условию,
то возвращается \texttt{true}, иначе возвращается \texttt{false}.
Если возвращается \texttt{false},
то есть объект ошибки НЕ соответствует условию,
то функция из первого параметра НЕ выполняется.\par
Использования метода \texttt{catchError} можно увидить на 
предыдущем рисунке~\ref{fig:future:2}.

\section{Ожидание Future метода}

В ходе развития языка Dart в нем появились ключевые слова управления работы
с асинхронными функциями.
Операторы \texttt{async} и \texttt{await} облегчают
написание асинхронного кода.
Применение \texttt{async-await} позволяет уйти
от прямого использования Future API, в частности,
его методов \texttt{then} и \texttt{catchError}.

Рассмотрим пример, на рисунке~\ref{fig:future:api}
код написанный на Future API.

\begin{image}
	\includegrph{Screenshot from 2024-10-12 20-31-39}
	\caption{Пример с использованием Future API}
	\label{fig:future:api}
\end{image}

Перепишем его с использованием async-await \rref{fig:async-await}.

\begin{image}
	\includegrph{Screenshot from 2024-10-12 20-21-26}
	\caption{Пример с использованием async-await}
	\label{fig:async-await}
\end{image}

Асинхронная функция --- это такая функция,
которая содержит как минимум одну асинхронную операцию
(хотя также вместе с этим может содержать выполнять и синхронные операции).
Асинхронная функция выглядит как синхронная за тем исключением,
что она использует операторы \texttt{async} и \texttt{await}.\par
Асинхронная функция выполняет синхронно весь код,
который идет до первого вызова выражения \texttt{await}.
Выражение \texttt{await} представляет асинхронную операцию.
Асинхронная операция --- это такая операция,
которая не блокирует выполнение других операций
и позволяет им выполняться до своего завершения.\par
Выражение \texttt{await} обычно возвращает объект \texttt{Future}.
Если возвращается объект другого типа, то он автоматически обертывается
во \texttt{Future}. И этот объект, который хранится во \texttt{Future},
мы можем получить простой операцией присваивания.\par
Стоит отметить, что если функция использует \texttt{await},
то она обязательно должна быть определена с ключевым словом \texttt{async}.
Также стоит отметить,
что асинхронная функция может содержать несколько выражений \texttt{await}.
В этом случае они выполняется последовательно: когда завершится предыдущее,
начинает выполняться последующее выражение \texttt{await}.\par
Если в процессе выполнения долговременной операции произошла ошибка,
то объект Future вместо конкретных данных будет содержать информацию об ошибке.
Для обработки подобной ситуации достаточно поместить
выражение \texttt{await} в блок \texttt{try..catch}.

\section{Приложение}

Переработаем имеющееся приложение,
выполненное на предыдущих практических работах, таким образом,
чтобы в нем была реализация асинхронной логики.

\subsection{Создание Api}

Для демонстрации работы со асинхронностью создали простой API
на FastAPI.

\subsubsection{Установка необходимых библиотек}

Сначала необходимо установить FastAPI и Uvicorn с помощью \texttt{pip}:
\verb|pip install fastapi uvicorn|

\subsubsection{Код API}

Код \rref{fig:fastapi} написан на Python с использованием библиотеки FastAPI
для создания REST API и библиотеки pydantic для работы с моделями данных.
Он описывает базовый функционал по созданию и получению задач.

\begin{image}
	\includegrph[scale=0.55]{Screenshot from 2024-10-12 19-37-48}
	\caption{Код FastAPI}
	\label{fig:fastapi}
\end{image}

\subsubsection{Запуск}

Если код находится в файле \texttt{task\_manager.py},
то сервер запускается с помощью следующей команды:
\verb|uvicorn task_manager:app --reload|.
После этого API будет доступен по адресу \url{http://127.0.0.1:8000}.

\subsection{Установка зависимости}

Пакет \texttt{http} во Flutter нужен для выполнения HTTP-запросов.
Он предоставляет набор высокоуровневых функций и классов,
которые упрощают работу с HTTP-ресурсами.

Некоторые методы, которые доступны в этой библиотеке:

\begin{itemize}
	\item GET --- для получения данных с сервера;
	\item POST --- для отправки данных на сервер;
	\item PUT --- для обновления данных на сервере;
	\item DELETE --- для удаления данных с сервера.
\end{itemize}

Для использования пакета \texttt{http} (версия 1.2.2) в проекте,
сначала его нужно прописать в зависимостях к проекту \rref{fig:http}.

\begin{image}
	\includegrph{Screenshot from 2024-10-12 17-13-09}
	\caption{Установка зависимости http}
	\label{fig:http}
\end{image}

\subsection{ApiService}

Этот класс \texttt{ApiService} \rref{fig:apiservice}
используется для взаимодействия с API сервера через HTTP-запросы.
Основная цель этого класса предоставить удобный интерфейс для работы с API,
чтобы другие части приложения могли легко использовать функции получения
и создания задач. 

\break

Рассмотрим каждую функцию класса подробнее:

\begin{itemize}
	\item \texttt{fetchTasks}:
		Эта функция делает запрос GET
		к URL \url{http://0.0.0.0:8000/tasks/}
		и возвращает список задач в формате JSON.
		Если статус кода ответа равен 200,
		то данные успешно получены и преобразуются в объекты Task.
		В противном случае генерируется исключение Exception.
	\item \texttt{createTask}:
		Эта функция выполняет POST-запрос к тому же URL
		и отправляет тело задачи в формате JSON.
		Если ответ имеет статус код 200,
		то задача успешно создана и возвращается объект Task,
		иначе генерируется исключение Exception.
\end{itemize}

\begin{image}
	\includegrph{Screenshot from 2024-10-12 18-42-19}
	\caption{Класс ApiService}
	\label{fig:apiservice}
\end{image}

Таким образом, используя этот класс,
разработчики могут сосредоточиться на логике приложения,
не заботясь о низкоуровневых деталях работы с HTTP-запросами.

\subsection{Модель Task}

Эта модель \rref{fig:model} описывает структуру данных
для задачи (\texttt{Task}).

\begin{image}
	\includegrph{Screenshot from 2024-10-12 19-34-31}
	\caption{Класс модели Task}
	\label{fig:model}
\end{image}

Каждая задача имеет следующие поля:

\begin{itemize}
	\item \texttt{id}: уникальный идентификатор задачи.
	\item \texttt{title}: название задачи.
	\item \texttt{description}: описание задачи (может быть пустым).
	\item \texttt{completed}: признак выполнения задачи (по умолчанию false).
\end{itemize}

Конструктор принимает обязательные параметры \texttt{id} и \texttt{title},
а также необязательный параметр \texttt{description}
и начальное значение \texttt{completed}.
Методы \texttt{fromJson} и \texttt{toJson} используются
для преобразования объектов \texttt{Task} в формат JSON и обратно.

\subsection{TaskListScreen}

Изменили медтоды \texttt{TaskListScreenState} \rref{fig:listscreen}
для использования реализованный раннее \texttt{ApiService}.

\begin{image}
	\includegrph{Screenshot from 2024-10-12 20-50-44}
	\caption{Класс TaskListScreenState}
	\label{fig:listscreen}
\end{image}

Добавлены:

\begin{itemize}
	\item Инициализация сервиса API:
		Класс \texttt{TaskListScreenState} инициализирует
		экземпляр \texttt{ApiService} при создании состояния.
	\item Получение списка задач:
		Используется метод \texttt{apiService.fetchTasks}
		для получения списка задач и сохранения результата
		в переменную \texttt{Future<List<Task>> futureTasks}.
	\item Добавление новой задачи:
		Функция \texttt{addTask} проверяет,
		есть ли введенное название задачи,
		создает новую задачу и вызывает метод \texttt{apiService.createTask}
		для её добавления на сервер.
		После успешного добавления обновляется список задач
		путем повторного вызова \texttt{apiService.fetchTasks}.
\end{itemize}

\clearpage

\section*{ВЫВОД}
\addcontentsline{toc}{section}{ВЫВОД}

В рамках практической работы были рассмотрены ключевые
аспекты асинхронного программирования,
включая использование Future методов.\par
Асинхронное программирование позволяет выполнять операции параллельно,
что увеличивает производительность и отзывчивость приложения.
Это особенно важно при работе с большими объемами данных
или сетевыми запросами.\par
Асинхронные Future методы позволяют создавать задачи,
которые выполняются независимо от основного потока выполнения программы.
Они могут быть использованы для обработки длительных операций
без блокировки основного потока.\par
Получение данных по итогу Future метода осуществляется
через использование слушателей событий или через ожидание завершения задачи.
Это позволяет гибко обрабатывать результаты асинхронных операций.\par
Ожидание Future метода позволяет синхронизировать выполнение других задач
до завершения текущего асинхронного метода.
Это обеспечивает последовательное выполнение логики приложения.\par
Также переработали имеющееся приложение,
выполненное на предыдущих практических работах,
таким образом, чтобы в нем была реализация асинхронной логики.

